<?xml version="1.0"?>
<section xml:id="trees_implementation">
  <title>Implementation</title>
  <p>Keeping in mind the definitions from the previous section,
            we can use the following functions to create and manipulate a binary tree:</p>
  <p>
    <ul>
      <li>
        <p><c>BinaryTree()</c> creates a new instance of a binary tree.</p>
      </li>
      <li>
        <p><c>getRootValue()</c> returns the object stored in the current node.</p>
      </li>
      <li>
        <p><c>setRootValue(value)</c> stores the object in parameter <c>value</c> in the current node.</p>
      </li>
      <li>
        <p><c>getLeftChild()</c> returns the binary tree corresponding to the left child of the current node.</p>
      </li>
      <li>
        <p><c>getRightChild()</c> returns the binary tree corresponding to the right child of the current node.</p>
      </li>
      <li>
        <p><c>insertLeft(value)</c> creates a new binary tree and installs it as the left child of the current node.</p>
      </li>
      <li>
        <p><c>insertRight(value)</c> creates a new binary tree and installs it as the right child of the current node.</p>
      </li>
    </ul>
  </p>
  <p>The key decision in implementing a tree is choosing a good internal storage technique.
            There are two very interesting possibilities, and we will examine both
            before choosing the one that is more suited to use in Java.  We call them <em>array of arrays</em> and <em>nodes and references</em>.</p>
</section>
