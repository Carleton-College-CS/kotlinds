<section xml:id="trees_search-tree-implementation">
  <title>Search Tree Implementation</title>
  <introduction>
  <p>A binary search tree (BST) relies on the property that
            keys that are less than the parent are found in the left subtree, and
            keys that are greater than the parent are found in the right subtree. We
            will call this the <term>BST property</term>. As we implement the <c>Map</c> interface
            as described above, the BST property will guide our implementation.
            <xref ref="i146_id1fig-simplebst"/> illustrates this property of a binary search
            tree, showing the keys without any associated values. Notice that the
            property holds for each parent and child. All of the keys in the left
            subtree are less than the key in the root. All of the keys in the right
            subtree are greater than the root.</p>
  <figure align="center" xml:id="i146_id1fig-simplebst">
    <caption>A Simple Binary Search Tree</caption>
    <image source="Trees/Figures/simpleBST.png" width="50%"/>
  </figure>
  </introduction>

  <subsection xml:id="construct-binary-search-tree">
    <title>Constructing a Binary Search Tree</title>
  <p>Now that you know what a binary search tree is, we will look at how a
            binary search tree is constructed. The search tree in
            <xref ref="i146_id1fig-simplebst"/> represents the nodes that exist after we have
            inserted the following keys in the order shown:
            <m>70, 31, 93, 94, 14, 23, 73</m>. Since 70 was the first key inserted into
            the tree, it is the root. Next, 31 is less than 70, so it becomes the
            left child of 70. Next, 93 is greater than 70, so it becomes the right
            child of 70. Now we have two levels of the tree filled, so the next key
            is going to be the left or right child of either 31 or 93. Since 94 is
            greater than 70 and 93, it becomes the right child of 93. Similarly 14
            is less than 70 and 31, so it becomes the left child of 31. 23 is also
            less than 31, so it must be in the left subtree of 31. However, it is
            greater than 14, so it becomes the right child of 14.</p>

  <p>To implement the binary search tree, we will use the nodes and
            references approach similar to the one we used to implement the linked
            list and the expression tree. However, because we must be able create
            and work with a binary search tree that is empty, our implementation
            will use two classes. The first class we will call <c>BinarySearchTree</c>,
            and the second class we will call <c>TreeNode</c>. The <c>BinarySearchTree</c>
            class has a reference to the <c>TreeNode</c> that is the root of the binary
            search tree. In most cases the external methods defined in the outer
            class simply check to see if the tree is empty. If there are nodes in
            the tree, the request is just passed on to a private method defined in
            the <c>BinarySearchTree</c> class that takes the root as a parameter. In
            the case where the tree is empty or we want to delete the key at the
            root of the tree, we must take special action. The code for the beginning of the
            <c>BinarySearchTree</c> class is shown in <xref ref="trees_lst-bst1"/>.</p>
  <listing xml:id="trees_lst-bst1"><program language="java" line-numbers="yes">
  <input>
import java.util.Iterator;

public class BinarySearchTree&lt;K extends Comparable&lt;K&gt;,
  V extends Comparable&lt;V&gt;&gt; {

    private TreeNode root;
    private int size;

    public BinarySearchTree() {
        this.root = null;
        size = 0;
    }

    public int size() {
        return size;
    }

    public TreeNode getRoot() {
        return root;
    }

  </input></program></listing>

  <note>
  <title>Java Note</title>
  <p>There are some new Java constructs to unpack here.
  First, in lines 3 and 4, we define this class as requiring two generic data types, <c>K</c> for the key and <c>V</c> for
  the value. We may need to do comparisons on both keys and values, so we want to make sure each data type
  <c>extends Comparable</c>.</p>

  <p>We would also like to be able to use an extended <c>for</c> loop to iterate through a <c>BinarySearchTree</c>, so we need to import the <c>Iterator</c> class in line 1. We will add the code for iteration in <xref ref="iterate-binary-search-tree"/>.
  </p>
  </note>

  <p>The <c>TreeNode</c> class provides many helper methods that make the work
            done in the <c>BinarySearchTree</c> class methods much easier. The
            constructor for a <c>TreeNode</c>, along with these helper methods, is
            shown in <xref ref="trees_lst-bst2"/>. We will put this class definition <em>inside</em> the <c>BinarySearchTree</c> class. This will automatically give a <c>TreeNode</c> access to all the <c>BinarySearchTree</c> properties, including the generic types <c>K</c> and <c>V</c>.

            As you can see in the listing, many of
            these helper methods help to classify a node according to its own
            position as a child (left or right) and the kind of children the node
            has.

            The <c>TreeNode</c> class will also explicitly keep track
            of the parent as an attribute of each node. You will see why this is
            important when we discuss the implementation for the <c>remove</c> method in <xref ref="remove-key-binary-search-tree"/>.</p>

  <p>We have <term>overloaded</term> the constructor. In lines 16&#x2013;22, the constructor
    is given all the information a <c>TreeNode</c> needs. Sometimes, though, we want to construct a <c>TreeNode</c> without only some of the information. The constructors in lines 8&#x2013;14 call the 5-argument constructor to provide the <q>missing</q> arguments. (Using <c>this</c> as a method name calls the constructor.)</p>
  <listing xml:id="trees_lst-bst2"><program language="java" line-numbers="yes"><input>
    class TreeNode {
        private K key;
        private V value;
        TreeNode leftChild;
        TreeNode rightChild;
        TreeNode parent;

        TreeNode(K key, V value) {
            this(key, value, null, null, null);
        }

        TreeNode(K key, V value, TreeNode parent) {
            this(key, value, null, null, parent);
        }

        TreeNode(K key, V value, TreeNode left, TreeNode right, TreeNode parent) {
            this.key = key;
            this.value = value;
            this.leftChild = left;
            this.rightChild = right;
            this.parent = parent;
        }

        /* Is this node a left child of a parent? */
        boolean isLeftChild() {
            return parent != null &amp;&amp; parent.leftChild == this;
        }

        /* Is this node a right child of a parent? */
        boolean isRightChild() {
            return parent != null &amp;&amp; parent.rightChild == this;
        }

        /* Is this the root node? (The root node has no parent) */
        boolean isRoot() {
            return parent == null;
        }

        /* Is this a leaf node? (Leaf nodes have no children) */
        boolean isLeaf() {
            return (leftChild == null &amp;&amp; rightChild == null);
        }

        /* Does this node have any children? */
        boolean hasAnyChild() {
            return leftChild != null || rightChild != null;
        }

        /* Does this node have both left and right children? */
        boolean hasChildren() {
            return leftChild != null &amp;&amp; rightChild != null;
        }

        void replaceValue(K key, V value, TreeNode left, TreeNode right) {
            this.key = key;
            this.value = value;
            this.leftChild = left;
            this.rightChild = right;
            if (this.leftChild != null) {
                this.leftChild.parent = this;
            }
            if (this.rightChild != null) {
                this.rightChild.parent = this;
            }
        }

        public K getKey() {
            return this.key;
        }

        public V getValue() {
            return this.value;
        }

        public String toString() {
            String keyStr = (key == null) ? "null" : key.toString();
            String valStr = (value == null) ? "null" : value.toString();
            return "key: " + key + " value: " + value + "\n  " +
                " left: " + leftChild + " right: " + rightChild +
                "parent: " + parent;
        }
    }
    </input></program></listing>

    <note>
    <title>Java Note</title>
    <p>Lines 76 and 77 introduce Java's <term>ternary operator</term>.  Writing an expression of the form:</p>
    <pre>variable = (condition) ? trueExpression : falseExpression;</pre>
    <p>is a shortcut for the following <c>if</c> statement:</p>
    <pre>
if (condition) {
    variable = trueExpression;
} else {
    variable = falseExpression;
}</pre>
    </note>
  </subsection>

  <subsection xml:id="put-binary-search-tree">
  <title>Inserting Keys and Values into a Binary Search Tree</title>
  <p>Now that we have the <c>BinarySearchTree</c> shell and the <c>TreeNode</c>, it
            is time to write the <c>put</c> method that will allow us to build our
            binary search tree. The <c>put</c> method is a method of the
            <c>BinarySearchTree</c> class. This method will check to see if the tree
            already has a root. If there is not a root, then <c>put</c> will create a
            new <c>TreeNode</c> and install it as the root of the tree. If a root node
            is already in place, then <c>put</c> calls the private recursive helper
            method <c>put</c> (with four parameters) to search the tree according to the following
            algorithm:</p>
  <p>
    <ul>
      <li>
        <p>Starting at the root of the tree, search the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.</p>
      </li>
      <li>
        <p>When there is no left or right child to search, we have found the position in the tree where the new node should be installed.</p>
      </li>
      <li>
        <p>To add a node to the tree, create a new <c>TreeNode</c> object and insert the object at the point discovered in the previous step.</p>
      </li>
    </ul>
  </p>

  <p><xref ref="trees_lst-put"/> shows the Java code for inserting a new node in the tree. The public <c>put</c> method with two arguments calls the he private <c>put</c> method, which is written recursively following the steps outlined above. Notice that when a new child is inserted into the tree, the <c>currentNode</c> is passed to the new tree as the parent.</p>

  <p>One important problem with our implementation of insertion is that duplicate keys are not handled properly. As our tree is implemented, a duplicate key will create a new node with the same key value in the right subtree of the node having the original key. The result of this is that the node with the new key will never be found during a search. A better way to handle the insertion of a duplicate key is for the value associated with the new key to replace the old value. We leave fixing this bug as an exercise for you.</p>

  <listing xml:id="trees_lst-put"><caption>The <c>put</c> Method</caption>
  <program language="java"><input>
   public void put(K key, V value) {
        if (this.root != null) {
            put(key, value, this.root);
        } else {
            this.root = new TreeNode(key, value);
        }
        this.size = this.size + 1;
    }

    private void put(K key, V value, TreeNode currentNode) {
        if (key.compareTo(currentNode.key) &lt; 1) {
            if (currentNode.leftChild != null) {
                put(key, value, currentNode.leftChild);
            } else {
                currentNode.leftChild = new TreeNode(key, value,
                    currentNode);
            }
        } else {
            if (currentNode.rightChild != null) {
                put(key, value, currentNode.rightChild);
            } else {
                currentNode.rightChild = new TreeNode(key, value,
                    currentNode);
            }
        }
    }
  </input></program></listing>

<note>
<title>Java Note</title>
<p>There are two methods named <c>put</c>, but Java does not have a problem with this because they have different <term>method signatures</term>: the method name, the number, and types of arguments. As long as these are different, there is no ambiguity when Java needs to figure out whch method to call. The return type and the access (<c>public</c> or <c>private</c>) are <em>not</em> part of the method signature.</p>
</note>
  <p><xref ref="i146_id2fig-bstput"/> illustrates the process for inserting a new node
            into a binary search tree. The lightly shaded nodes indicate the nodes
            that were visited during the insertion process.</p>
  <figure align="center" xml:id="i146_id2fig-bstput">
    <caption>Inserting a Node with Key = 19</caption>
    <image source="Trees/Figures/bstput.png" width="50%"/>
  </figure>
  <exercises>
    <title>Self Check</title>
    <exercise label="bst_1">
      <statement>
        <p>Which of the trees shows a correct binary search tree given that the keys were
                inserted in the following order 5, 30, 2, 40, 25, 4.</p>
      </statement>
      <choices>
        <choice>
          <statement>
            <p>
              <image source="SortSearch/Figures/bintree_a.png" width="50%">
                <description>
                  <p/>
                </description>
              </image>
            </p>
          </statement>
          <feedback>
            <p>Remember, starting at the root keys less than the root must be in the left subtree, while keys greater than the root go in the right subtree.</p>
          </feedback>
        </choice>
        <choice correct="yes">
          <statement>
            <p>
              <image source="SortSearch/Figures/bintree_b.png" width="50%">
                <description>
                  <p/>
                </description>
              </image>
            </p>
          </statement>
          <feedback>
            <p>good job.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p>
              <image source="SortSearch/Figures/bintree_c.png" width="50%">
                <description>
                  <p/>
                </description>
              </image>
            </p>
          </statement>
          <feedback>
            <p>This looks like a binary tree that satisfies the full tree property needed for a heap.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
  </exercises>
  </subsection>

  <subsection xml:id="get-binary-search-tree">
    <title>Retrieving Values for a Key in a Binary Search Tree</title>
  <p>Once the tree is constructed, the next task is to implement the
            retrieval of a value for a given key. The <c>get</c> method is less complex
            than the <c>put</c> method because it searches the tree recursively
            until it gets to a non-matching leaf node or finds a matching key. When
            a matching key is found, the value stored in the payload of the node is
            returned.</p>

  <p><xref ref="trees_lst-get"/> shows the code for <c>get</c> and the private <c>get</c> helper method.
            The search code in the helper method uses the same
            logic for choosing the left or right child as the <c>put</c> helper method. Notice
            that the <c>get</c> helper method returns a <c>TreeNode</c> to <c>get</c>, which allows
            the helper method to be used as a flexible method for other
            <c>BinarySearchTree</c> methods that may need to make use of other data
            from the <c>TreeNode</c> besides the payload.</p>
  <listing xml:id="trees_lst-get">
  <caption>The <c>get</c> Method</caption>
  <program language="java"><input>
    public V get(K key) {
        if (this.root != null) {
            TreeNode result = get(key, this.root);
            if (result != null) {
                return result.value;
            }
        }
        return null;
    }

    private TreeNode get(K key, TreeNode currentNode) {
        if (currentNode == null) {
            return null;
        }
        if (key.compareTo(currentNode.key) == 0) {
            return currentNode;
        } else if (key.compareTo(currentNode.key) &lt; 0) {
            return get(key, currentNode.leftChild);
        } else {
            return get(key, currentNode.rightChild);
        }
    }
</input></program></listing>

    <p>We can use the <c>get</c> helper method when implementing the <c>containsKey</c> method in
    <xref ref="trees_lst-contains"/>;
    if it returns a node, we return <c>true</c>; if it returns <c>null</c>, we return <c>false</c>:</p>


  <listing xml:id="trees_lst-contains">
  <caption>The <c>containsKey</c> Method</caption>
  <program language="java"><input>
    public boolean containsKey(K key) {
        TreeNode result = get(key, this.root);
        return (result != null);
    }
  </input></program></listing>

    <p>At this point we have enough to implement a program to test our tree, shown in <xref ref="lst_bst-example1"/>:</p>
<listing xml:id="lst_bst-example1">
<caption>Sample Binary Search Tree Program</caption>
<program language="java"><input>
public class BinarySearchTreeExample {

    public static void main(String[] args) {
        BinarySearchTree&lt;String, String&gt; tree = new BinarySearchTree&lt;&gt;();

        tree.put("France", "Paris");
        tree.put("Japan", "Tokyo");
        tree.put("Albania", "Tirana");
        tree.put("Madagascar", "Antananarivo");
        tree.put("Zimbabwe", "Harare");
        tree.put("South Korea", "Seoul");

        System.out.println(tree.get("Japan"));  // "Tokyo"
        System.out.println(tree.get("Brazil")); // null
    }
}
</input></program></listing>

<p>This is a good time to take a break before proceeding to the remainder of this section.</p>

</subsection>

<subsection xml:id="iterate-binary-search-tree">
    <title>Iterating over a Binary Search Tree</title>

  <p>Suppose that we would like to iterate over all the keys in the
            tree in order. You already know how to traverse a
            binary tree in order, using the <c>inorder</c> traversal algorithm.
            However, writing an iterator is a bit different since an iterator
            should return only one node each time it is called.</p>

  <p>To make our iterator work, we will need two methods in the <c>TreeNode</c> class:</p>
  <p>
    <ul>
        <li><c>findSuccessor(node)</c> takes a node as its argument and returns the next node with the next-largest key, called the <term>successor</term>. This will move us through the tree one node at a time.</li>
        <li><c>findMinimmChild(node)</c> returns the minimum key in a subtree whose root is the given node. We need this to find the smallest key in the tree as our starting point for the iterator, and also when finding a succesor.</li>
    </ul>
</p>

<p>Let's address <c>findSuccessor</c> first. There are three cases to consider when looking for the successor:</p>
  <p>
    <ol marker="1">
      <li>
        <p>If the node has a right child, then the successor is the smallest key
                    in the right subtree.</p>
      </li>
      <li>
        <p>If the node has no right child and is the left child of its parent, then the parent is the successor.</p>
      </li>
      <li>
        <p>If the node is the right child of its parent, and itself has no right child, then the successor to this node is the successor of its parent, excluding this node.</p>
      </li>
    </ol>
  </p>

  <p><xref ref="lst_find-successor"/> gives the code for finding a successor:</p>

  <listing xml:id="lst_find-successor">
  <caption>The <c>findSucessor</c> Method</caption>
  <program language="java" line-numbers="yes"><input>
TreeNode findSuccessor() {
    TreeNode successor = null;
    if (rightChild != null) {
        successor = rightChild.findMinimumChild();
    } else {
        if (parent != null) {
            if (isLeftChild()) {
                successor = parent;
            } else {
                parent.rightChild = null;
                successor = parent.findSuccessor();
                parent.rightChild = this;
            }
        }
    }
    return successor;
  </input></program>
  </listing>

  <p>Lines 3 and 4 handle the first case (there is a right child) by calling
    <c>findMinimumChild</c>. Line 7 tests to see if this node is a left child of its parent (the second case). Otherwise, we have the third case and <c>this</c> is the right child of its parent. Line 10 temporary excludes this node from the tree, and line 12 retores the <c>parent</c>'s right child.</p>

    <p><xref ref="lst_find-minimum-child"/> shows the code for finding the minimum child. You should convince yourself that the minimum value key in any binary search tree is the leftmost child of the tree. Therefore the <c>findMinimumChild</c> method follows the <c>leftChild</c> references in each node of the subtree until it reaches a node that does not have a left child. The code uses a <c>while</c> loop rather than using recursion to follow the left children:</p>

    <listing xml:id="lst_find-minimum-child">
    <program language="java" line-numbers="yes">
    <input>
TreeNode findMinimumChild() {
    TreeNode current = this;
    while (current.leftChild != null) {
        current = current.leftChild;
    }
    return current;
}
    </input></program></listing>

    <p>Now that we have these methods, we have to modify the <c>BinarySearchTree</c> class. We change the first lines of the class to declare that this class is <c>Iterable</c>:</p>

    <program language="java"><input>
import java.util.Iterator;

public class BinarySearchTree&lt;K extends Comparable&lt;K&gt;, V extends Comparable&lt;V&gt;&gt;
    implements Iterable&lt;BinarySearchTree&lt;K, V&gt;.TreeNode&gt; {
</input></program>

<p>Our next step is to create an <c>Iterator</c> class that Java uses when it starts a <c>for</c> loop. (We can use it ourselves,too.) </p>

    <listing xml:id="lst_iterator_class">
    <caption>Initializing an <c>Iterator</c></caption>
    <program language="java" line-numbers="yes">
    <input>
    class TreeIterator implements Iterator&lt;BinarySearchTree&lt;K, V&gt;.TreeNode&gt; {
        TreeNode iteratorNode;

        public TreeIterator() {
            if (root.leftChild == null) {
                iteratorNode = root;
            } else {
                iteratorNode = root.findMinimumChild();
            }
        }

        public boolean hasNext() {
            return iteratorNode != null;
        }

        public TreeNode next() {
            TreeNode result = null;
            if (iteratorNode != null) {
                result = iteratorNode;
                iteratorNode = iteratorNode.findSuccessor();
            }
            return result;
        }
    }
    </input></program></listing>

    <p>Line 2 creates a <c>TreeNode</c> that keeps track of where we are in the tree.</p>
    <p>The constructor is in lines 4&#x2013;10. It sets the <c>iteratorNode</c> to the first (smallest) element in the tree. If the root doesn't have a left child, then the root must be the smallest element, as everything to the right of the root is larger than the root.  Otherwise, if there is a left child, we must find its minimum child in line 8.</p>

    <p>We now implement two methods used by the iterator.  <c>hasNext</c> in lines&#xA0;12&#x2013;14 returns <c>true</c> if there is a next node; <c>false</c> otherwise<mdash/>this is used to decide when to end a loop using the iterator.  The <c>next</c> method in lines&#xA0;16&#x2013;23 moves the iterator to the successor node (or null if we have finished traversing the tree) and returns it.</p>

    <p>At last! We can now write the program in <xref ref="lst_bst-example2"/> that tests insertion, accessing nodes,  and traversal of a binary search tree. In lines&#xA0;18&#x2013;21 we iterate through the tree with a <c>for</c> loop; in lines&#xA0;25&#x2013;31 we set up an iterator of our own for use with a <c>while</c> loop.</p>

    <listing xml:id="lst_bst-example2">
    <caption>Using the Binary Searh Tree</caption>
    <program language="java" line-numbers="yes">
    <input>
import java.util.Iterator;

public class BinarySearchTreeExample {

    public static void main(String[] args) {
        BinarySearchTree&lt;String, String&gt; tree = new BinarySearchTree&lt;&gt;();

        tree.put("France", "Paris");
        tree.put("Japan", "Tokyo");
        tree.put("Albania", "Tirana");
        tree.put("Madagascar", "Antananarivo");
        tree.put("Zimbabwe", "Harare");
        tree.put("South Korea", "Seoul");

        System.out.println(tree.get("Japan"));  // "Tokyo"
        System.out.println(tree.get("Brazil")); // null

        for (BinarySearchTree.TreeNode node: tree) {
            System.out.println(node.getKey() + " -&gt; "
                + node.getValue());
        }

        System.out.println("-----------------------------");

        Iterator&lt;BinarySearchTree&lt;String, String&gt;.TreeNode&gt; iter =
            tree.iterator();

        while (iter.hasNext()) {
            BinarySearchTree.TreeNode node = iter.next();
            System.out.println(node.getKey() + " -&gt; " + node.getValue());
        }

    }
}
    </input></program></listing>

    <p>In line 18, we must use the fully qualified class name <c>BinarySearchTree.TreeNode</c> because the
    <c>TreeNode</c> class is nested inside the <c>BinarySearchTree</c> class. In line 25, we must also add
    the data types for the key and value.</p>
    </subsection>

<subsection xml:id="remove-key-binary-search-tree">
    <title>Removing a Key from a Binary Search Tree</title>

  <p>Finally, we turn our attention to the most challenging operation on the binary search tree, the deletion of a key (see <xref ref="trees_lst-remove-key-1"/>). The first task is to find the node to delete by searching the tree. If the tree has more than one node we search using the <c>get</c> method to find the <c>TreeNode</c> that needs to be removed. If the tree only has a single node, that means we are removing the root of the tree, but we still must check to make sure the key of the root matches the key that is to be deleted. In either case, if the key is not found the <c>remove</c> method raises an error.</p>

  <listing xml:id="trees_lst-remove-key-1"><program language="java"><input>
    public TreeNode removeKey(K key) {
        if (size > 1) {
            TreeNode nodeToRemove = get(key, root);
            if (nodeToRemove != null) {
                removeNode(nodeToRemove);
                size = size - 1;
                return nodeToRemove;
            } else {
                throw new NoSuchElementException(
                    key.toString() + " not in tree.");
            }
        } else if (size == 1 &amp;&amp; root.key.equals(key)) {
            root = null;
            size = size - 1;
            return null;
        } else {
            throw new NoSuchElementException(
                    key.toString() + " not in tree.");
        }
    }

    public void removeNode(TreeNode currentNode) {
        // to be determined...
    }
</input></program></listing>
  <p>Once we&#x2019;ve found the node containing the key we want to delete, there
            are three cases that we must consider:</p>
  <p>
    <ol marker="1">
      <li>
        <p>The node to be deleted has no children (see <xref ref="fig-bstdel1"/>).</p>
      </li>
      <li>
        <p>The node to be deleted has only one child (see <xref ref="fig-bstdel2"/>).</p>
      </li>
      <li>
        <p>The node to be deleted has two children (see <xref ref="fig-bstdel3"/>).</p>
      </li>
    </ol>
  </p>
  <figure align="center" xml:id="fig-bstdel1">
    <caption>Deleting Node 16, a Node without Children</caption>
    <image source="Trees/Figures/bstdel1.png" width="50%"/>
  </figure>
  <figure align="center" xml:id="fig-bstdel2">
    <caption>Deleting Node 25, a Node That Has a Single Child</caption>
    <image source="Trees/Figures/bstdel2.png" width="50%"/>
  </figure>
  <figure align="center" xml:id="fig-bstdel3">
    <caption>Deleting Node 5, a Node with Two Children</caption>
    <image source="Trees/Figures/bstdel3.png" width="50%"/>
  </figure>

  <p>The first case is straightforward. If the current node has no children,
            all that has to happen is to delete the node and remove the reference to this
            node in the parent. The code for this case is shown in <xref ref="trees_lst-remove-case-1"/>.</p>
  <listing xml:id="trees_lst-remove-case-1"><caption>Removing a Leaf Node</caption>
  <program language="java"><input>
       if (currentNode.isLeaf() {
            if (currentNode == currentNode.parent.leftChild) {
                currentNode.parent.leftChild = null;
            } else {
                currentNode.parent.rightChild = null;
            }
        }
  </input></program></listing>

  <p>The second case is only slightly more complicated. If a node has only a
            single child, then we promote the child to take the place of
            its parent. The code for this case is shown in <xref ref="trees_lst-remove-case-2"/>. As
            you look at this code, you will see that there are six cases to consider.
            Since the cases are symmetric with respect to either having a left or
            right child, we will just discuss the case where the current node has a
            left child. The decision proceeds as follows:</p>
  <p>
    <ol marker="1">
      <li>
        <p>If the current node is a left child, then we only need to update the
                    parent reference of the left child to point to the parent of the
                    current node, and then update the left child reference of the parent
                    to point to the current node&#x2019;s left child.</p>
      </li>
      <li>
        <p>If the current node is a right child, then we only need to update the
                    parent reference of the left child to point to the parent of the
                    current node, and then update the right child reference of the parent
                    to point to the current node&#x2019;s left child.</p>
      </li>
      <li>
        <p>If the current node has no parent, it must be the root. In this case
                    we will just replace the <c>key</c>, <c>value</c>, <c>left_child</c>, and
                    <c>right_child</c> data by calling the <c>replace_value</c> method on the
                    root.</p>
      </li>
    </ol>
  </p>
  <listing xml:id="trees_lst-remove-case-2"><pre>else:  # removing a node with one child
    if current_node.get_left_child():
        if current_node.is_left_child():
            current_node.left_child.parent = current_node.parent
            current_node.parent.left_child = current_node.left_child
        elif current_node.is_right_child():
            current_node.left_child.parent = current_node.parent
            current_node.parent.right_child = current_node.left_child
        else:
            current_node.replace_value(
                current_node.left_child.key,
                current_node.left_child.value,
                current_node.left_child.left_child,
                current_node.left_child.right_child,
            )
    else:
        if current_node.is_left_child():
            current_node.right_child.parent = current_node.parent
            current_node.parent.left_child = current_node.right_child
        elif current_node.is_right_child():
            current_node.right_child.parent = current_node.parent
            current_node.parent.right_child = current_node.right_child
        else:
            current_node.replace_value(
                current_node.right_child.key,
                current_node.right_child.value,
                current_node.right_child.left_child,
                current_node.right_child.right_child,
            )</pre></listing>

  <p>The third case is the most difficult case to handle. If a node has two
            children, then it is unlikely that we can simply promote one of them to
            take the node&#x2019;s place. We can, however, search the tree for a node that
            can be used to replace the one scheduled for deletion. What we need is a
            node that will preserve the binary search tree relationships for both of
            the existing left and right subtrees. The node that will do this is the
            node that has the next-largest key in the tree. We call this node the
            <term>successor</term>, and we will look at a way to find the successor shortly.</p>
            <p>
            The successor is guaranteed to have no more than one child, so we know
            how to remove it using the two cases for deletion that we have already
            implemented. Once the successor has been removed, we put it in
            the tree in place of the node to be deleted. The code
            to handle the third case is shown in <xref ref="trees_lst-remove-key-3"/>.</p>
  <p>In <xref ref="trees_lst-remove-key-3"/> we make use of the helper methods
            <c>findSuccessor</c> and <c>spliceOut</c> to find and remove the successor.
            The reason we use <c>spliceOut</c> is that it
            goes directly to the node we want to splice out and makes the right
            changes. We could call <c>remove</c> recursively, but then we would waste
            time searching again for the key node.</p>
  <listing xml:id="trees_lst-remove-key-3"><pre>elif current_node.has_children():  # removing a node with two children
    successor = current_node.find_successor()
    successor.splice_out()
    current_node.key = successor.key
    current_node.value = successor.value</pre></listing>
  <p>The code to find the successor is shown below (see <xref ref="trees_lst-splice-out"/>) and, as
            you can see, is a method of the <c>TreeNode</c> class. This code makes use
            of the same properties of binary search trees that cause an inorder
            traversal to print out the nodes in the tree from smallest to largest.</p>

  <p>The first condition is the only one that matters for us when deleting a
            node from a binary search tree. However, the <c>findSuccessor</c> method
            has other uses that we will explore in the exercises at the end of this
            chapter.</p>
  <p>The <c>findMin</c> method is called to find the minimum key in a subtree.
            You should convince yourself that the minimum value key in any binary
            search tree is the leftmost child of the tree. Therefore the <c>findMin</c>
            method follows the <c>leftChild</c> references in each node of the
            subtree until it reaches a node that does not have a left child.</p>
  <listing xml:id="trees_lst-splice-out"><pre>
def splice_out(self):
    if self.is_leaf():
        if self.is_left_child():
            self.parent.left_child = None
        else:
            self.parent.right_child = None
    elif self.has_any_child():
        if self.left_child:
            if self.is_left_child():
                self.parent.left_child = self.left_child
            else:
                self.parent.right_child = self.left_child
            self.left_child.parent = self.parent
        else:
            if self.is_left_child():
                self.parent.left_child = self.right_child
            else:
                self.parent.right_child = self.right_child
            self.right_child.parent = self.parent</pre></listing>

</subsection>



    <subsection xml:id="complete-binary-search-tree">
    <title>The Complete BinarySearchTree and TreeNode Code</title>
  <p>At this point you may want to download the entire file containing the
            full version of the <c>BinarySearchTree</c> and <c>TreeNode</c> classes.</p>
  <program xml:id="completebstcode" interactive="activecode" language="python">
    <input>
class TreeNode:
    def __init__(self, key, value, left=None, right=None, parent=None):
        self.key = key
        self.value = value
        self.left_child = left
        self.right_child = right
        self.parent = parent

    def is_left_child(self):
        return self.parent and self.parent.left_child is self

    def is_right_child(self):
        return self.parent and self.parent.right_child is self

    def is_root(self):
        return not self.parent

    def is_leaf(self):
        return not (self.right_child or self.left_child)

    def has_any_child(self):
        return self.right_child or self.left_child

    def has_children(self):
        return self.right_child and self.left_child

    def replace_value(self, key, value, left, right):
        self.key = key
        self.value = value
        self.left_child = left
        self.right_child = right
        if self.left_child:
            self.left_child.parent = self
        if self.right_child:
            self.right_child.parent = self

    def find_successor(self):
        successor = None
        if self.right_child:
            successor = self.right_child.find_min()
        else:
            if self.parent:
                if self.is_left_child():
                    successor = self.parent
                else:
                    self.parent.right_child = None
                    successor = self.parent.find_successor()
                    self.parent.right_child = self
        return successor

    def find_min(self):
        current = self
        while current.left_child:
            current = current.left_child
        return current

    def splice_out(self):
        if self.is_leaf():
            if self.is_left_child():
                self.parent.left_child = None
            else:
                self.parent.right_child = None
        elif self.has_any_child():
            if self.left_child:
                if self.is_left_child():
                    self.parent.left_child = self.left_child
                else:
                    self.parent.right_child = self.left_child
                self.left_child.parent = self.parent
            else:
                if self.is_left_child():
                    self.parent.left_child = self.right_child
                else:
                    self.parent.right_child = self.right_child
                self.right_child.parent = self.parent

    def __iter__(self):
        if self:
            if self.left_child:
                for elem in self.left_child:
                    yield elem
            yield self.key
            if self.right_child:
                for elem in self.right_child:
                    yield elem


class BinarySearchTree:
    def __init__(self):
        self.root = None
        self.size = 0

    def __len__(self):
        return self.size

    def __iter__(self):
        return self.root.__iter__()

    def put(self, key, value):
        if self.root:
            self._put(key, value, self.root)
        else:
            self.root = TreeNode(key, value)
        self.size = self.size + 1

    def _put(self, key, value, current_node):
        if key &lt; current_node.key:
            if current_node.left_child:
                self._put(key, value, current_node.left_child)
            else:
                current_node.left_child = TreeNode(
                    key, value, parent=current_node
                )
        else:
            if current_node.right_child:
                self._put(key, value, current_node.right_child)
            else:
                current_node.right_child = TreeNode(
                    key, value, parent=current_node
                )

    def __setitem__(self, key, value):
        self.put(key, value)

    def get(self, key):
        if self.root:
            result = self._get(key, self.root)
            if result:
                return result.value
        return None

    def _get(self, key, current_node):
        if not current_node:
            return None
        if current_node.key == key:
            return current_node
        elif key &lt; current_node.key:
            return self._get(key, current_node.left_child)
        else:
            return self._get(key, current_node.right_child)

    def __getitem__(self, key):
        return self.get(key)

    def __contains__(self, key):
        return bool(self._get(key, self.root))

    def delete(self, key):
        if self.size &gt; 1:
            node_to_remove = self._get(key, self.root)
            if node_to_remove:
                self._delete(node_to_remove)
                self.size = self.size - 1
            else:
                raise KeyError("Error, key not in tree")
        elif self.size == 1 and self.root.key == key:
            self.root = None
            self.size = self.size - 1
        else:
            raise KeyError("Error, key not in tree")

    def _delete(self, current_node):
        if current_node.is_leaf():  # removing a leaf
            if current_node == current_node.parent.left_child:
                current_node.parent.left_child = None
            else:
                current_node.parent.right_child = None
        elif current_node.has_children():  # removing a node with two children
            successor = current_node.find_successor()
            successor.splice_out()
            current_node.key = successor.key
            current_node.value = successor.value
        else:  # removing a node with one child
            if current_node.left_child:
                if current_node.is_left_child():
                    current_node.left_child.parent = current_node.parent
                    current_node.parent.left_child = current_node.left_child
                elif current_node.is_right_child():
                    current_node.left_child.parent = current_node.parent
                    current_node.parent.right_child = current_node.left_child
                else:
                    current_node.replace_value(
                        current_node.left_child.key,
                        current_node.left_child.value,
                        current_node.left_child.left_child,
                        current_node.left_child.right_child,
                    )
            else:
                if current_node.is_left_child():
                    current_node.right_child.parent = current_node.parent
                    current_node.parent.left_child = current_node.right_child
                elif current_node.is_right_child():
                    current_node.right_child.parent = current_node.parent
                    current_node.parent.right_child = current_node.right_child
                else:
                    current_node.replace_value(
                        current_node.right_child.key,
                        current_node.right_child.value,
                        current_node.right_child.left_child,
                        current_node.right_child.right_child,
                    )

    def __delitem__(self, key):
        self.delete(key)


my_tree = BinarySearchTree()
my_tree["a"] = "a"
my_tree["q"] = "quick"
my_tree["b"] = "brown"
my_tree["f"] = "fox"
my_tree["j"] = "jumps"
my_tree["o"] = "over"
my_tree["t"] = "the"
my_tree["l"] = "lazy"
my_tree["d"] = "dog"

print(my_tree["q"])
print(my_tree["l"])
print("There are {} items in this tree".format(len(my_tree)))
my_tree.delete("a")
print("There are {} items in this tree".format(len(my_tree)))

for node in my_tree:
    print(my_tree[node], end=" ")
print()
        </input>
  </program>
  </subsection>
</section>
